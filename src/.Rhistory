# compute and store part-worth ranges for each attribute
part.worth.ranges <- conjoint.results$contrasts
for (index.for.attribute in seq(along=conjoint.results$contrasts))
part.worth.ranges[index.for.attribute] <-
dist(range(conjoint.results$part.worths[index.for.attribute]))
conjoint.results$part.worth.ranges <- part.worth.ranges
sum.part.worth.ranges <- sum(as.numeric(conjoint.results$part.worth.ranges))
# compute and store importance values for each attribute
attribute.importance <- conjoint.results$contrasts
for(index.for.attribute in seq(along=conjoint.results$contrasts))
attribute.importance[index.for.attribute] <-
(dist(range(conjoint.results$part.worths[index.for.attribute]))/
sum.part.worth.ranges) * 100
conjoint.results$attribute.importance <- attribute.importance
# data frame for ordering attribute names
attribute.name <- names(conjoint.results$contrasts)
attribute.importance <- as.numeric(attribute.importance)
temp.frame <- data.frame(attribute.name,attribute.importance)
conjoint.results$ordered.attributes <-
as.character(temp.frame[sort.list(
temp.frame$attribute.importance,decreasing = TRUE),"attribute.name"])
# data frame for ordering attribute names
attribute.name <- names(conjoint.results$contrasts)
attribute.importance <- as.numeric(attribute.importance)
temp.frame <- data.frame(attribute.name,attribute.importance)
conjoint.results$ordered.attributes <-
as.character(temp.frame[sort.list(
temp.frame$attribute.importance,decreasing = TRUE),"attribute.name"])
# respondent internal consistency added to list structure
conjoint.results$internal.consistency <- summary(lin_reg)$r.squared
print.digits = 2
# user-defined function for printing conjoint measures
if (print.digits == 2)
pretty.print <- function(x) {sprintf("%1.2f",round(x,digits = 2))}
if (print.digits == 3)
pretty.print <- function(x) {sprintf("%1.3f",round(x,digits = 3))}
# report conjoint measures to console
# use pretty.print to provide nicely formated output
for (k in seq(along=conjoint.results$ordered.attributes)) {
cat("\n","\n")
cat(conjoint.results$ordered.attributes[k],"Levels: ",
unlist(conjoint.results$xlevels[conjoint.results$ordered.attributes[k]]))
cat("\n"," Part-Worths:  ")
cat(pretty.print(unlist(conjoint.results$part.worths
[conjoint.results$ordered.attributes[k]])))
cat("\n"," Standardized Part-Worths:  ")
cat(pretty.print(unlist(conjoint.results$standardized.part.worths
[conjoint.results$ordered.attributes[k]])))
cat("\n"," Attribute Importance:  ")
cat(pretty.print(unlist(conjoint.results$attribute.importance
[conjoint.results$ordered.attributes[k]])))
}
pdf(file = "laptop_preference_results_new.pdf", width=8.5, height=11)
spine.chart(conjoint.results)
dev.off()  # close the graphics output device
pdf(file = "laptop_preference_results_new.pdf", width=8.5, height=11)
#### consider the rating as Level 1, respondent as Level 2
#### random intercept model
multilin_RI <- lmer(rating ~ operating_system + RAM + storage + screen_size + battery + price + (1 | resp_id), data=df)
summary(multilin_RI) # a lot of variance in how respondent use rating scale
vcov(multilin_RI) # compute the covariance matrix
lme4::VarCorr(multilin_RI) %>% print(comp = c("Variance", "Std.Dev"),digits = 2)
AIC(multilin_RI)  ## 7458.452
# fit linear regression
lin_reg <- lm(rating ~ operating_system + RAM + storage + screen_size + battery + price, data=df)
summary(lin_reg)
# load the data
df <- read.csv("Laptop_Research_Survey.csv")
df <- data.frame(df)
head(df)
# convert the variable to factors
for (i in c('operating_system',"RAM","price","storage","screen_size","battery","nationality","Education")){
df[[i]] <- as.factor(df[[i]])
}
# fit linear regression
lin_reg <- lm(rating ~ operating_system + RAM + storage + screen_size + battery + price, data=df)
summary(lin_reg)
# fit linear regression
lin_reg <- lm(rating ~ operating_system + RAM + storage + screen_size + battery + price, data=df)
summary(lin_reg)
AIC(lin_reg) # 7727.448
#### consider the rating as Level 1, respondent as Level 2
#### random intercept model
multilin_RI <- lmer(rating ~ operating_system + RAM + storage + screen_size + battery + price + (1 | resp_id), data=df)
summary(multilin_RI) # a lot of variance in how respondent use rating scale
vcov(multilin_RI) # compute the covariance matrix
rm(list = ls())
# load the data
df <- read.csv("Laptop_Research_Survey.csv")
df <- data.frame(df)
head(df)
# convert the variable to factors
for (i in c('operating_system',"RAM","price","storage","screen_size","battery","nationality","Education")){
df[[i]] <- as.factor(df[[i]])
}
# fit linear regression
lin_reg <- lm(rating ~ operating_system + RAM + storage + screen_size + battery + price, data=df)
summary(lin_reg)
AIC(lin_reg) # 7727.448
#### consider the rating as Level 1, respondent as Level 2
#### random intercept model
multilin_RI <- lmer(rating ~ operating_system + RAM + storage + screen_size + battery + price + (1 | resp_id), data=df)
summary(multilin_RI) # a lot of variance in how respondent use rating scale
library(ggplot2)
library(vcd)  # data visualization for categorical variables
library("ggthemes")
library("grid")
library(ggpubr)
setwd("D:/software/R Files/Business and Customer Analytics/Final Projects")
# Demogra_data <- read.csv('Demographic_data.csv')
Demogra_data <- read.csv('Laptop_Research_Survey.csv')
Demogra_data$Age <- factor(Demogra_data$Age, levels = c("18", "18-20", "20-23", "24-26", "27-30", ">30"))
Demogra_data$Gender <- factor(Demogra_data$Gender, levels = c("male", "female", "prefer not to say"))
Demogra_data$Education <- factor(Demogra_data$Education)
Demogra_data$Work. <- factor(Demogra_data$Work.)
summary(Demogra_data)
# Demogra_data <- read.csv('Demographic_data.csv')
Demogra_data <- read.csv('../data/Laptop_Research_Survey.csv')
Demogra_data$Age <- factor(Demogra_data$Age, levels = c("18", "18-20", "20-23", "24-26", "27-30", ">30"))
Demogra_data$Gender <- factor(Demogra_data$Gender, levels = c("male", "female", "prefer not to say"))
Demogra_data$Education <- factor(Demogra_data$Education)
Demogra_data$Work. <- factor(Demogra_data$Work.)
summary(Demogra_data)
# ------------- Relation between Age and rating -------------------
ggplot(data=Demogra_data,aes(x=Age,y=rating)) +geom_boxplot()
mosaic( ~ Age + rating, data = Demogra_data,
labeling_args = list(set_varnames = c(rating = "Response to Computers", Age = "Age level")),
highlighting = "Age", highlighting_fill=rainbow)
# ------------- Relation between Gender and rating -------------------
ggplot(data=Demogra_data,aes(x=Gender,y=rating)) +geom_boxplot()
# examine the frequency table for education
with(Demogra_data,table(rating, Gender))
with(Demogra_data,prop.table(table(rating, Gender), margin=1))
with(Demogra_data,chisq.test(table(rating, Gender)))
mosaic( ~ Gender + rating, data = Demogra_data,
labeling_args = list(set_varnames = c(rating = "Response to Computers", Age = "Gender level")),
highlighting = "Gender", highlighting_fill=rainbow)
# ------------- Relation between Education and rating -------------------
ggplot(data=Demogra_data,aes(x=Education,y=rating)) +geom_boxplot()
# examine the frequency table for education
with(Demogra_data,table(rating, Education))
# -----------------------------------------------
# Focus on Education, attributes of computer and rating
# -----------------------------------------------
num_Bachelor <- nrow(Demogra_data[Demogra_data$Education=="Bachelor's degree",])/9
num_Mas_Sci <- nrow(Demogra_data[Demogra_data$Education=="Master of Science",])/9
num_Dr_Phi <- nrow(Demogra_data[Demogra_data$Education=="Doctor of Philosophy",])/9
num_not_stu <- nrow(Demogra_data[Demogra_data$Education=="Not a student",])/9
num_not_say <- nrow(Demogra_data[Demogra_data$Education=="prefer not to say",])/9
# -----------  Relation between Education, RAM and rating  --------------
pic <- Demogra_data[,c(2,4,12)]
pic <- aggregate(pic$rating, by=list(type=pic$Education, pic$RAM),mean)
names(pic) <-c ("Education","RAM", "Average_rating")
pic$RAM <- factor(pic$RAM)
ggplot(data=pic, mapping=aes(x = RAM, y = Average_rating,fill=Education))+
geom_bar(stat="identity",position=position_dodge(0.75))
# -----------  Relation between Education, Screen_size and rating  --------------
pic <- Demogra_data[,c(2,6,12)]
pic <- aggregate(pic$rating, by=list(type=pic$Education, pic$screen_size),mean)
names(pic) <-c ("Education","Screen_size", "Average_rating")
pic$Screen_size <- factor(pic$Screen_size)
ggplot(data=pic, mapping=aes(x = Screen_size, y = Average_rating,fill=Education))+
geom_bar(stat="identity",position=position_dodge(0.75))
View(multilin_RI)
library(lattice)
library(cluster)
library(ggplot2)
library(gridExtra)
# load data
df <- read.csv("..data/Laptop_Research_Survey.csv")
# load data
df <- read.csv("../data/Laptop_Research_Survey.csv")
df <- df[,c(1,10,11,12,13)]
df <- unique(df)
df <- df[-1]
# plot demographic data
p_1 <- ggplot(as.data.frame(prop.table(table(df$Age))), aes(x=Var1, y=Freq, fill=Var1)) +
geom_bar(stat="identity") +
labs(x = "Age", y = "Frequency") +
theme(legend.position="none")
p_2 <- ggplot(as.data.frame(prop.table(table(df$Gender))), aes(x=Var1, y=Freq, fill=Var1)) +
geom_bar(stat="identity") +
labs(x = "Gender", y = "Frequency") +
theme(legend.position="none")
p_3 <- ggplot(as.data.frame(prop.table(table(df$Work))), aes(x=Var1, y=Freq, fill=Var1)) +
geom_bar(stat="identity") +
labs(x = "Work", y = "Frequency") +
theme(legend.position="none")
p_4 <- ggplot(as.data.frame(prop.table(table(df$Education))), aes(x=Var1, y=Freq, fill=Var1)) +
geom_bar(stat="identity") +
labs(x = "Education", y = "Frequency") +
theme(legend.position="none")
lay <- rbind(c(1,1,2,2,3,3),
c(NA,4,4,4,4,NA))
grid.arrange(p_1, p_2, p_3, p_4, layout_matrix = lay, top = "Demographic Data")
library(lme4)
library(ggpubr)
library(sjPlot)
library(lattice)
source("spine_chart_utility.R")
##########################################
# step1. consider the data including     #
# both the Italian and Chinese market    #
##########################################
# load the data
df <- read.csv("../data/Laptop_Research_Survey.csv")
df <- data.frame(df)
head(df)
str(df)
summary(df)
# convert the variable to factors
for (i in c('operating_system',"RAM","price","storage","screen_size","battery","nationality","Education")){
df[[i]] <- as.factor(df[[i]])
}
# fit linear regression
lin_reg <- lm(rating ~ operating_system + RAM + storage + screen_size + battery + price, data=df)
summary(lin_reg)
AIC(lin_reg) # 7720.239
# set options to obtain sum contrast
backup_options <- options()
options(contrasts=c("contr.sum","contr.poly"))
lin_reg <- lm(rating ~ operating_system + RAM + storage + screen_size + battery + price, data=df)
# set options to obtain sum contrast
backup_options <- options()
options(contrasts=c("contr.sum","contr.poly"))
lin_reg <- lm(rating ~ operating_system + RAM + storage + screen_size + battery + price, data=df)
# save key list elements of the fitted model as needed for conjoint measures
conjoint.results <-
lin_reg[c("contrasts","xlevels","coefficients")]
conjoint.results$attributes <- names(conjoint.results$contrasts)
part.worths <- conjoint.results$xlevels  # list of same structure as xlevels
end.index.for.coefficient <- 1  # intitialize skipping the intercept
part.worth.vector <- NULL # used for accumulation of part worths
for(index.for.attribute in seq(along=conjoint.results$contrasts)) {
nlevels <- length(unlist(conjoint.results$xlevels[index.for.attribute]))
begin.index.for.coefficient <- end.index.for.coefficient + 1
end.index.for.coefficient <- begin.index.for.coefficient + nlevels -2
last.part.worth <- -sum(conjoint.results$coefficients[
begin.index.for.coefficient:end.index.for.coefficient])
part.worths[index.for.attribute] <-
list(as.numeric(c(conjoint.results$coefficients[
begin.index.for.coefficient:end.index.for.coefficient],
last.part.worth)))
part.worth.vector <-
c(part.worth.vector,unlist(part.worths[index.for.attribute]))
}
conjoint.results$part.worths <- part.worths
standardize <- function(x) {(x - mean(x)) / sd(x)}
conjoint.results$standardized.part.worths <-
lapply(conjoint.results$part.worths,standardize)
# compute and store part-worth ranges for each attribute
part.worth.ranges <- conjoint.results$contrasts
for (index.for.attribute in seq(along=conjoint.results$contrasts))
part.worth.ranges[index.for.attribute] <-
dist(range(conjoint.results$part.worths[index.for.attribute]))
conjoint.results$part.worth.ranges <- part.worth.ranges
sum.part.worth.ranges <- sum(as.numeric(conjoint.results$part.worth.ranges))
# compute and store importance values for each attribute
attribute.importance <- conjoint.results$contrasts
for(index.for.attribute in seq(along=conjoint.results$contrasts))
attribute.importance[index.for.attribute] <-
(dist(range(conjoint.results$part.worths[index.for.attribute]))/
sum.part.worth.ranges) * 100
conjoint.results$attribute.importance <- attribute.importance
# data frame for ordering attribute names
attribute.name <- names(conjoint.results$contrasts)
attribute.importance <- as.numeric(attribute.importance)
temp.frame <- data.frame(attribute.name,attribute.importance)
conjoint.results$ordered.attributes <-
as.character(temp.frame[sort.list(
temp.frame$attribute.importance,decreasing = TRUE),"attribute.name"])
# respondent internal consistency added to list structure
conjoint.results$internal.consistency <- summary(lin_reg)$r.squared
print.digits = 2
# user-defined function for printing conjoint measures
if (print.digits == 2)
pretty.print <- function(x) {sprintf("%1.2f",round(x,digits = 2))}
if (print.digits == 3)
pretty.print <- function(x) {sprintf("%1.3f",round(x,digits = 3))}
# report conjoint measures to console
# use pretty.print to provide nicely formated output
for (k in seq(along=conjoint.results$ordered.attributes)) {
cat("\n","\n")
cat(conjoint.results$ordered.attributes[k],"Levels: ",
unlist(conjoint.results$xlevels[conjoint.results$ordered.attributes[k]]))
cat("\n"," Part-Worths:  ")
cat(pretty.print(unlist(conjoint.results$part.worths
[conjoint.results$ordered.attributes[k]])))
cat("\n"," Standardized Part-Worths:  ")
cat(pretty.print(unlist(conjoint.results$standardized.part.worths
[conjoint.results$ordered.attributes[k]])))
cat("\n"," Attribute Importance:  ")
cat(pretty.print(unlist(conjoint.results$attribute.importance
[conjoint.results$ordered.attributes[k]])))
}
pdf(file = "laptop_preference_results_new.pdf", width=8.5, height=11)
spine.chart(conjoint.results)
dev.off()  # close the graphics output device
options(backup_options)
library(lme4)
library(ggpubr)
library(sjPlot)
library(lattice)
source("spine_chart_utility.R")
##########################################
# step1. consider the data including     #
# both the Italian and Chinese market    #
##########################################
# load the data
df <- read.csv("../data/Laptop_Research_Survey.csv")
df <- data.frame(df)
head(df)
str(df)
summary(df)
# convert the variable to factors
for (i in c('operating_system',"RAM","price","storage","screen_size","battery","nationality","Education")){
df[[i]] <- as.factor(df[[i]])
}
# fit linear regression
lin_reg <- lm(rating ~ operating_system + RAM + storage + screen_size + battery + price, data=df)
summary(lin_reg)
AIC(lin_reg) # 7720.239
#############################################
# step2. try to compute the part-worths and #
# plot the spine chart of student customers #
#############################################
# set options to obtain sum contrast
backup_options <- options()
options(contrasts=c("contr.sum","contr.poly"))
lin_reg <- lm(rating ~ operating_system + RAM + storage + screen_size + battery + price, data=df)
# save key list elements of the fitted model as needed for conjoint measures
conjoint.results <-
lin_reg[c("contrasts","xlevels","coefficients")]
conjoint.results$attributes <- names(conjoint.results$contrasts)
part.worths <- conjoint.results$xlevels  # list of same structure as xlevels
end.index.for.coefficient <- 1  # intitialize skipping the intercept
part.worth.vector <- NULL # used for accumulation of part worths
for(index.for.attribute in seq(along=conjoint.results$contrasts)) {
nlevels <- length(unlist(conjoint.results$xlevels[index.for.attribute]))
begin.index.for.coefficient <- end.index.for.coefficient + 1
end.index.for.coefficient <- begin.index.for.coefficient + nlevels -2
last.part.worth <- -sum(conjoint.results$coefficients[
begin.index.for.coefficient:end.index.for.coefficient])
part.worths[index.for.attribute] <-
list(as.numeric(c(conjoint.results$coefficients[
begin.index.for.coefficient:end.index.for.coefficient],
last.part.worth)))
part.worth.vector <-
c(part.worth.vector,unlist(part.worths[index.for.attribute]))
}
conjoint.results$part.worths <- part.worths
standardize <- function(x) {(x - mean(x)) / sd(x)}
conjoint.results$standardized.part.worths <-
lapply(conjoint.results$part.worths,standardize)
# compute and store part-worth ranges for each attribute
part.worth.ranges <- conjoint.results$contrasts
for (index.for.attribute in seq(along=conjoint.results$contrasts))
part.worth.ranges[index.for.attribute] <-
dist(range(conjoint.results$part.worths[index.for.attribute]))
conjoint.results$part.worth.ranges <- part.worth.ranges
sum.part.worth.ranges <- sum(as.numeric(conjoint.results$part.worth.ranges))
# compute and store importance values for each attribute
attribute.importance <- conjoint.results$contrasts
for(index.for.attribute in seq(along=conjoint.results$contrasts))
attribute.importance[index.for.attribute] <-
(dist(range(conjoint.results$part.worths[index.for.attribute]))/
sum.part.worth.ranges) * 100
conjoint.results$attribute.importance <- attribute.importance
# data frame for ordering attribute names
attribute.name <- names(conjoint.results$contrasts)
attribute.importance <- as.numeric(attribute.importance)
temp.frame <- data.frame(attribute.name,attribute.importance)
conjoint.results$ordered.attributes <-
as.character(temp.frame[sort.list(
temp.frame$attribute.importance,decreasing = TRUE),"attribute.name"])
# respondent internal consistency added to list structure
conjoint.results$internal.consistency <- summary(lin_reg)$r.squared
print.digits = 2
# user-defined function for printing conjoint measures
if (print.digits == 2)
pretty.print <- function(x) {sprintf("%1.2f",round(x,digits = 2))}
if (print.digits == 3)
pretty.print <- function(x) {sprintf("%1.3f",round(x,digits = 3))}
# report conjoint measures to console
# use pretty.print to provide nicely formated output
for (k in seq(along=conjoint.results$ordered.attributes)) {
cat("\n","\n")
cat(conjoint.results$ordered.attributes[k],"Levels: ",
unlist(conjoint.results$xlevels[conjoint.results$ordered.attributes[k]]))
cat("\n"," Part-Worths:  ")
cat(pretty.print(unlist(conjoint.results$part.worths
[conjoint.results$ordered.attributes[k]])))
cat("\n"," Standardized Part-Worths:  ")
cat(pretty.print(unlist(conjoint.results$standardized.part.worths
[conjoint.results$ordered.attributes[k]])))
cat("\n"," Attribute Importance:  ")
cat(pretty.print(unlist(conjoint.results$attribute.importance
[conjoint.results$ordered.attributes[k]])))
}
pdf(file = "laptop_preference_results_new.pdf", width=8.5, height=11)
spine.chart(conjoint.results)
dev.off()  # close the graphics output device
options(backup_options)
# fit linear regression
lin_reg <- lm(rating ~ operating_system + RAM + storage + screen_size + battery + price, data=df)
summary(lin_reg)
library(lme4)
library(ggpubr)
library(sjPlot)
library(lattice)
source("spine_chart_utility.R")
##########################################
# step1. consider the data including     #
# both the Italian and Chinese market    #
##########################################
# load the data
df <- read.csv("../data/Laptop_Research_Survey.csv")
df <- data.frame(df)
head(df)
str(df)
summary(df)
# convert the variable to factors
for (i in c('operating_system',"RAM","price","storage","screen_size","battery","nationality","Education")){
df[[i]] <- as.factor(df[[i]])
}
backup_options <- options()
# fit linear regression
lin_reg <- lm(rating ~ operating_system + RAM + storage + screen_size + battery + price, data=df)
summary(lin_reg)
AIC(lin_reg) # 7720.239
# set options to obtain sum contrast
options(contrasts=c("contr.sum","contr.poly"))
lin_reg <- lm(rating ~ operating_system + RAM + storage + screen_size + battery + price, data=df)
# save key list elements of the fitted model as needed for conjoint measures
conjoint.results <-
lin_reg[c("contrasts","xlevels","coefficients")]
conjoint.results$attributes <- names(conjoint.results$contrasts)
part.worths <- conjoint.results$xlevels  # list of same structure as xlevels
end.index.for.coefficient <- 1  # intitialize skipping the intercept
part.worth.vector <- NULL # used for accumulation of part worths
for(index.for.attribute in seq(along=conjoint.results$contrasts)) {
nlevels <- length(unlist(conjoint.results$xlevels[index.for.attribute]))
begin.index.for.coefficient <- end.index.for.coefficient + 1
end.index.for.coefficient <- begin.index.for.coefficient + nlevels -2
last.part.worth <- -sum(conjoint.results$coefficients[
begin.index.for.coefficient:end.index.for.coefficient])
part.worths[index.for.attribute] <-
list(as.numeric(c(conjoint.results$coefficients[
begin.index.for.coefficient:end.index.for.coefficient],
last.part.worth)))
part.worth.vector <-
c(part.worth.vector,unlist(part.worths[index.for.attribute]))
}
conjoint.results$part.worths <- part.worths
standardize <- function(x) {(x - mean(x)) / sd(x)}
conjoint.results$standardized.part.worths <-
lapply(conjoint.results$part.worths,standardize)
# compute and store part-worth ranges for each attribute
part.worth.ranges <- conjoint.results$contrasts
for (index.for.attribute in seq(along=conjoint.results$contrasts))
part.worth.ranges[index.for.attribute] <-
dist(range(conjoint.results$part.worths[index.for.attribute]))
conjoint.results$part.worth.ranges <- part.worth.ranges
sum.part.worth.ranges <- sum(as.numeric(conjoint.results$part.worth.ranges))
# compute and store importance values for each attribute
attribute.importance <- conjoint.results$contrasts
for(index.for.attribute in seq(along=conjoint.results$contrasts))
attribute.importance[index.for.attribute] <-
(dist(range(conjoint.results$part.worths[index.for.attribute]))/
sum.part.worth.ranges) * 100
conjoint.results$attribute.importance <- attribute.importance
# data frame for ordering attribute names
attribute.name <- names(conjoint.results$contrasts)
attribute.importance <- as.numeric(attribute.importance)
temp.frame <- data.frame(attribute.name,attribute.importance)
conjoint.results$ordered.attributes <-
as.character(temp.frame[sort.list(
temp.frame$attribute.importance,decreasing = TRUE),"attribute.name"])
# respondent internal consistency added to list structure
conjoint.results$internal.consistency <- summary(lin_reg)$r.squared
print.digits = 2
# user-defined function for printing conjoint measures
if (print.digits == 2)
pretty.print <- function(x) {sprintf("%1.2f",round(x,digits = 2))}
if (print.digits == 3)
pretty.print <- function(x) {sprintf("%1.3f",round(x,digits = 3))}
# report conjoint measures to console
# use pretty.print to provide nicely formated output
for (k in seq(along=conjoint.results$ordered.attributes)) {
cat("\n","\n")
cat(conjoint.results$ordered.attributes[k],"Levels: ",
unlist(conjoint.results$xlevels[conjoint.results$ordered.attributes[k]]))
cat("\n"," Part-Worths:  ")
cat(pretty.print(unlist(conjoint.results$part.worths
[conjoint.results$ordered.attributes[k]])))
cat("\n"," Standardized Part-Worths:  ")
cat(pretty.print(unlist(conjoint.results$standardized.part.worths
[conjoint.results$ordered.attributes[k]])))
cat("\n"," Attribute Importance:  ")
cat(pretty.print(unlist(conjoint.results$attribute.importance
[conjoint.results$ordered.attributes[k]])))
}
pdf(file = "laptop_preference_results_new.pdf", width=8.5, height=11)
spine.chart(conjoint.results)
dev.off()  # close the graphics output device
# fit linear regression
lin_reg <- lm(rating ~ operating_system + RAM + storage + screen_size + battery + price, data=df)
summary(lin_reg)
options(backup_options)
# fit linear regression
lin_reg <- lm(rating ~ operating_system + RAM + storage + screen_size + battery + price, data=df)
summary(lin_reg)
